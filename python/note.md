리팩토링 - 결과와 상관없이 코드의 가독성을 높이는 과정

일처리 순서

1. 이해
2. 순서(절차)
3. 진행

4. 기본
5. 문제해결 능력
6. 라이브러리의 문서와 예제를 통해 공부

엘라스틱 서치

<!-- requests, urllib.request 요청 차이 -->

작업은 끊을 수 있으면 최대한 끊어서

발표자료에 배포할 때 트러블슈팅 정리
포트폴리오

- 자기소개

  - 이름
  - 나이
  - 전화번호
  - 이메일
  - 자격증
  - 학력

- 역량

- 작업물
  - 전체적인 프로젝트 소개
  - 프로젝트 주요 기능

포트폴리오에 해결능력을 강조할 문제와 해결방법을 추가

발표시간 15 ~ 20분

# OpenSearch

## OpenSearch란

- AWS에서 제공하는 데이터 검색 및 분석 제품

# ELK

## ELK란

- Elasticsearch, Logstash, Kibana 세 가지 프로젝트로 구성된 스택

  - Elasticsearch : 검색 및 분석 엔진
  - Logstatsh : 데이터를 수집, 전환하고 원하는 대상에게 전송할 수 있도록 하는 데이터 수집 도구
  - Kibana : 로그 및 이벤트 도구에 사용하는 시각화 및 탐색 도구

- 6월 21일(수) : 1시간 - 5교시, 특강, 취업 담당
  - 21일까지 이력서, 자기소개서 작성 후 제출
  - 제출x 상담x
  - 강사님 의견 듣고 싶으면 제출
- 6월 24일(토) : 7시간, 특강, 외부

# ppt

이미지만 넣지말고 설명을 적는게 중요

# 발표, 취업

## 발표

- 팀장이 앉은 사람 기준 왼쪽으로
- 발표자는 문쪽 창문에 서서 대기
- 발표는 차분하고 정확하고 큰 목소리로
  - 실수하면 정정멘트 후 다시 진행
- 모르는 부분은 부족한 부분이라 인정하고 추후 보완하겠다고 대답

## 취업

- 업무는 명확하게 적혀있을 수록 좋은 회사
- 왜 다른 부분은 안 배우셨나요? -> 프론트, 백엔드, 파이썬을 통한 분석 과정을 기본부터 배웠기 때문에 새로운 기술이 필요하면 잘 습득할 수 있습니다.
- 채용이 적어 이력서 최대한 많이 지원
- 내가 가장 잘 할 수 있는 부분 1, 2개를 집중적으로 어필

### 이력서

### 자기소개서

- 폰트, 폰트 크기
- 단락 끝나면 줄바꿈, 공백으로 가독성

# SW개발

## 공통

- 몰두하는 일
- 지속적인 학습 -> 기존의 지식을 포기

## 프론트

- 섬세한 센스, 생산성

## 백엔드

- 안정적, 효율적으로 개발하는 것이 중요
- 보이지 않는 영역(서버, 성능, 안정성)
- 맵퍼
  - node.js : JavaScript
  - django : Python
  - spring : Java

## 개발 업무

- 과제 할당 : 요구사항
- 과제 분석 : 요구사항에 대한 기능 분석(추가, 수정, 삭제등의 작업)
- 개발 : 기능 개발, 버그 수정, 코드 리뷰
- 테스트 : 로직, 성능, 가독성, 가용성
- QA : 품질 테스트(QA팀이 없으면 개발자가 진행) / 테스트를 자동화하는 추세
- 배포~유지보수 : 빌드배포 자동화(Dev/Ops부분)
  - CI(지속적인 통합, 코드 변경사항 통합)
  - CD(지속적인 배포, 코드가 반영되는 것 프로덕션 환경까지 반영)

## 연차별 변화

- 교육(회사에 대한 교육, 기술 스택) : 회사에 따라 다름(없는 회사도 존재)
- 프로 : 단독 서비스 개발
- PM, 리더 : PM(관리자)로 넘어가거나 실무자로 남음

## 직무 준비 과정

- 다양한 분야(제조, 금융, 이커머스, 게임, 방산, SI 등)
- 다양한 프로그래밍 언어, 프레임워크
- 다양한 유형(기술 전문가, 도메인 전문가, UX/UI 전문가, 아키테쳐등)
- 내가 원하는 것을 찾는게 먼저 / 메타인지를 하는 것
  - 기술 스택을 쌓아 여러 분야를 다루는 가
  - 한 기술를 깊이 파는가

** 백엔드도 프론트를 안하는 건 아니다 **

- 내부 사용자(admin)를 백엔드가 개발하기도 함

## 본인의 스토리

- 본인만의 스토리를 작성하는 것이 중요

##

- ERP
- SM

# 백엔드

## Spring

- Spring 사용 이유
  - 한국은 오랫동안 Spring으로 개발했기 때문에 Legacy Project를 사용하기 위해 Spring 사용
  - 유지보수 용이성

## Spring vs Spring Boot

- Spring Boot
  - 내장형 톰캣
  - 의존성 설치 자동화
  - Spring 기반이기 때문에 Spring의 이해도가 Spring Boot 효율을 높여줌

## 개발툴

- 형상관리 : github, bitbucket, sourcetree
- 에디터 : vsc, webstorm, jsfiddle(웹 IDE), eclipse(무료, 무거움), intellij(유료, 세팅 간소화)
- Diff : Compare Beyond Diff
  - 실제 코드와 기존 코드와의 차이를 보여주는 툴
  - 버전 관리툴
- SQL : Oracle, MySQL(AWS : RDS), postgresql / RDBMS의 원리는 비슷하기 때문에 하나의 RDBMS를 집중적으로 공부
- OS : Linux(centos, redhat, ubuntu), windows

## 백엔드 로드맵

- roadmap.sh

1. 인터넷
   - 웹 개발이기 때문에 인터넷에 대한 지식이 필요
   - DNS 동작 방식
1. 언어

1. 형상관리

   - 협업을 위한 부분

1. OS

   - 기본적인 터미널 명령어
   - 프로세스 관리
   - 로그

1. 관계형 데이터베이스

   - postgreSQL : 통계에 강점

1. No(Not Only SQL)SQL 데이터베이스

   - MongoDB, TimeScale, Firebase, Redis(메모리에 올라가는 DB, 캐쉬 이용), HBase

1. 데이터베이스

   - ORMs : 객체로 쿼리를 전달
     - JPA :
     - Mybatis : 통계, 복잡한 조회
   - ACID
     - 원자성 :
     - 일관성 :
     - 독립성 :
     - 지속성 :
   - Transactions : 작업의 최소 단위
     - 트랜젝션의 전파단계
   - N+1 Problem
     - 개체의 연관관계
   - Normalization
     - 정규화

1. Scaling Databases

   - Database Index
   - Data Replication
     - 데이터 베이스를 분리
       - master : 수정
       - slave : 조회
   - Sharding Strategies
     - 테이블 파티션

1. API(중요)

   - 인증
   - REST : 실제 실무에선 안 지켜 지는 경우도 많음
   -

1. Caching

   - Client Side
   - Server Side

1. Test

1. CI / CD

   - 회사에 따라 백엔드 개발자가 할 수도 있음

1. Architectural Patterns

   - Monolithic Apps
     - 한 파일에 모든 작업을 구성
   - Microservices
     - 작업을 분리하여 구성
     - 유지보수가 어려움
     - 로그 분석이 어려움
     - 비용이 높아짐
   - Serverless
     - 서버 없이 클라우드 서버

1. Message Brokers

   - queue 형식으로 요청을 저장하여 요청이 유실하지 않기 위해 사용
   - kafka, MQ

1. Docker
   - 가상 서버
   - QA가 DB Test시 Docker를 이용함

# 회사 고르는 기준

- 자신이 하고 싶은 분야를 먼저 정하는 것이 중요
- 자신이 가고 싶은 회사의 신년사를 확인해 회사의 진행방향이 어떻게 되는지 파악
- 해당 회사의 경력직 채용공고를 확인해 필요한 기술스택을 확실히 파악 가능
- 주식회사라면 DART에서 사업 보고서, 분기 보고서를 확인
  - 회사 개요
  - 사업
  - 임원 및 직원
    - CEO, 개발 실장이 박사라면 연구중심일 확률이 높음
    - 임원들의 학력을 확인
- 스타트업
  - Series B 이상부터 가볼만 한 회사
  - Series C 이상받은 회사는 안정적인 회사
  - 오너가 어떤 사람인지 파악하는 것도 중요
  - 사업조직인지 직무조직인지 파악
    - 사업 조직 : 성장속도가 빠름
    - 직무 조직 : 해당 직무에 대해 고민해볼 시간이 많음

## 전통적인 산업

- 제조
  - 하드웨어 기술이 중요
  - 기술이 특화된 분야라 도메인의 지식이 중요
- 금융
  - 트래픽이 많이 발생(서버의 안정성)
- 수직적 조직
- 연봉이 높은 편

## 중간 특징의 산업

- SI
- 업무 시스템을 주로 개발
- 트래픽이 많이 발생하진 않음
- 고객의 니즈를 잘 파악하고 해결해줄 수 있으면 좋음

## 신규 산업

- IT 서비스
- 게임
- 수평적 조직(네이버같이 오래 서비스를 한 회사는 보수적인 편) / 회사별로 다를 수도 있음
- 연봉이 회사별로 차등이 심함
- 트래픽이 많이 발생(서버의 안정성)

# 개발자의 소통법

## 기획서, 화면 설계서

- 기획자와 개발자가 소통하는 방법

## 코드

- 가독성 있는 코드

## ERD

- 아키텍쳐의 변화로 외래키를 설정하지 않는 경우가 많아짐
  - MicroService로 아키텍쳐가 변화하면서 각 도메인별로 영향을 줄이기 위해 외래키 설정을 안함
- 외래키를 설정하진 않지만 구조파악을 위해 관계는 나타내줌

## Github

- Readme.md파일을 자세히 작성

### Architecture

- cloudcraft : AWS architecture를 그릴 수 있는 무료 툴

## API 명세서

- 프론트엔드가 호출할 API 명세서
- jsfiddle
- Swagger : API명세서

1. 로그인 API

   - request

     - Method : Post
       /user/login
     - Body Parameter

     ```
        {
          "id" : "abcd",
          "pwd" : "1234"
        }
     ```

   - response

     - Response Message

     ```
     Name    |  Type  | Description
     --------------------------------------------
     code    | String | 결과코드(SUCCESS / ERROR)
     --------------------------------------------
     message | String | 메세지
     ```

     ```
         {
           "code" : "200",
           "message" : "",
         }
     ```

1. 일자별 로그인 수

   - request

     - Method : Get
       /user/date/count

   - response

     - Response Message

     ```
     Name    |  Type  | Description
     --------------------------------------------
     code    | String | 결과코드(SUCCESS / ERROR)
     --------------------------------------------
     message | String | 메세지
     --------------------------------------------
     data    |        |
       date   | String | 날짜(yyyy-MM-dd)
       count  | Number | 로그인 수
     ```

     ```
         {
           "code" : "200",
           "message" : "",
           "data" : {
               "date" : 2023-06-24
               "count" : 10
           }
         }
     ```

1. 일자별 부서별 로그인 수

   - request

     - Method : Get
       /user/date/dept/count

   - response

     - Response Message

     ```
     Name    |  Type  | Description
     --------------------------------------------
     code    | String | 결과코드(SUCCESS / ERROR)
     --------------------------------------------
     message | String | 메세지
     --------------------------------------------
     data    |        |
       date   | String | 날짜(yyyy-MM-dd)
       dept   | String | 부서명
       count  | Number | 로그인 수
     ```

     ```
         {
           "code" : "200",
           "message" : "",
           "data" : {
               "date" : 2023-06-24
               "dept" : 인사
               "count" : 10
           }
         }
     ```

1. 월별 부서별 접속자 수

   - request

     - Method : Get
       /user/month/dept/count

   - response

     - Response Message

     ```
     Name    |  Type  | Description
     --------------------------------------------
     code    | String | 결과코드(SUCCESS / ERROR)
     --------------------------------------------
     message | String | 메세지
     --------------------------------------------
     data    |        |
     month  | String | 날짜(yyyy-MM)
     dept   | String | 부서별
     count  | Number | 로그인 수
     ```

     ```
         {
           "code" : "200",
           "message" : "",
           "data" : {
               "date" : 2023-06
               "dept" : 인사
               "count" : 10
           }
         }
     ```

1. 공휴일을 제외한 로그인 접속자 수

   - request

     - Method : Get
       /user/no-holiday/count

   - response

     - Response Message

     ```
     Name    |  Type  | Description
     --------------------------------------------
     code    | String | 결과코드(SUCCESS / ERROR)
     --------------------------------------------
     message | String | 메세지
     --------------------------------------------
     data    |        |
      count  | Number | 로그인 수
     ```

     ```
         {
           "code" : "200",
           "message" : "",
           "data" : {
               "date" : 2023-06-24
               "count" : 10
           }
         }
     ```

# 오픈 소스(차트, 그리드)

- plotly, highchart, chartjs
- jqgrid, datatables, ag-grid

## 선택조건

1. 유/무료 여부
1. 개발자 경험 여부
1. 미경험시 학습시간
1. 해당 기능에 얼마나 적합한지

# 크로스 브라우징, 크로스 도메인

## 크로스 브라우징

- 브라우저의 특성에 따라 페이지가 정상적으로 작동하지 않을 수 있기 때문에 브라우저에 따라 설정을 다르게 해줘야 하는 것
- 모든 환경에서 지원해야 한다면 라이브러리를 사용하는 것이 좋음
  - 라이브러리는 모든 환경에서 지원하기 위해 호환성을 중요시 하기 때문에

## 크로스 도메인

- Cross origin requests Error
  - 외부에서 서버로 연결할 때 발생하는 에러
  - Server to Server통신으로 해결 가능

# SQL

- 동적 쿼리(MyBatis)

## SQL 처리 vs Code 처리

- 데이터 베이스와 통신을 최소화
- 쿼리의 복잡성을 최소화
- 코드에서 list반복문을 최소화
- 정답은 케바케, 위 모든 조건이 적절히 섞여야 함
- MySQL의 경우 함수 실행을 반복적으로 실행하면 캐시에 저장되기 때문에 처리 속도가 빨라질 수 있다

## 공부방법

- 내가 뭘 할지 모를 땐 뭘 만들고 싶은지 고민
- 뭘 만들고 싶은지 정했다면 사용할 기술을 정하고 그 기술을 사용해보기
- 내가 공부하고 있는게 시장에서 필요한 기술인지 확인
- 정리하는 습관이 중요

# Q&A

## 새로운 기술 학습

1. 공식 문서(중요)
1. 동영상
1. 책
1. 실무에선 할 줄 아는 개발자

## 개발 과정

- 테스트할 수 있는 환경이 구현돼있어 해당 환경에서 테스트

## 신입 업무

- 레거시 코드에 작업을 하려면 기존 코드에 대한 이해가 필요하기 때문에 잘 시키지 않는다
- 제품에 대한 이해가 가능한 업무
  - 정리되지 않은 API를 정리
- 유지보수와 수정

## 코딩 테스트 준비

- 백준이나 미트코드의 플랫폼에서 준비
  - 알고리즘에 대한 이해도 필요
  - 코딩대회에 나가보는걸 추천
- 지원을 많이 해 코딩테스트를 많이 경험해보는 것도 좋음

## 면접

- 적극성, 모르면 모른다는 걸 인정하고 배우겠는다는 의지 표현 or 모르는 부분을 배경지식으로 생각해봐 대답
- 현재 회사에서 작업하고 있는 기술 스택과 얼마나 일치하는지 중요
- 긍정적인 대답, 태도
- 문제 해결에 대한 포인트

## 사내 문화

### 교육

1. 제품에 대한 이해
1. 커뮤니케이션(사내 시스템)
1. 실제 필요한 기술
1. 카카오톡 오픈채팅방에 특정 기술에 대한 채팅방이 존재

### 야근

- 장애가 많이 발생하는 시기에 따라 야근하는 횟수가 달라짐
- 서비스가 성장하는 과정에선 서버가 견딜 수 없는 상태가 올 수 있는데 이때도 야근
- SI에선 요구사항이 늦게까지 나오지 않으면 야근

### 신입

- 코딩능력, 소통능력이 중요
- 많이 질문하는 적극성, 문제를 이해하는 센스

## 기타

- AI를 개발도구로서 사용(생상성 증진)
- 회사가 요구하는 경험, 요구하는 기술 스택이 필요할 때 지원하면 몸값을 높일 수 있음
- 프리랜서는 계약 관계이기 때문에 계약된 부분만 작업
- 첫 회사 연봉에 따라 앞으로의 연봉이 정해질 가능성이 높음
- IT의 역사가 깊지 않기 때문에 아직 미래를 알긴 어렵다
- 공부를 하는 시간을 정해놓고 그 시간 외엔 쉴려고 함
- 2 ~ 3년차에 이직 가능
- 자극을 많이 받을 수 있는 오픈채팅방에서 정보 습득
- 기술블로그를 운영하는 대기업
- 링크드인에 좋은 자료
- 잘 검색해서 필요한 정보, 적합한 정보를 찾는 것도 중요
- Mac을 많이 사용 / Linux와 유사하게 cli로 작업할 수 있는 부분이 있기 때문에
