  [Python]
    - 라이브러리와 호환성을 위해 낮은 버전을 사용
    - 라이브러리와 가장 호환이 잘 되는 버전은 7버전
    - 절차지향과 객체지향의 특성을 둘 다 가지고 있음
      - 모든 것을 객체로 만들어 사용
      - 라인을 위에서 하나씩 처리
    - 라인을 하나씩 처리 -> 인터프리터 언어(대화형 언어)
    - 문자와 문자열을 구분하지 않음 -> '', "" 둘 다 표현 가능 / 내부적으론 ''로 관리
    - 파이썬 파일(.py) - Module(실행단위) - script(실행파일) / 파이썬파일은 script라 실행파일로 작동함
    - Java의 메소드 = 함수
    - 파이썬은 2버전과 3버전의 문법이 다름

  [Type]
    - 정수형, 실수형은 있지만 크기가 고정되지 않음
    - 파이썬은 여러 개의 값은 항상 묶어서 관리

    - 타입 변환은 변환이 가능해야 함수 사용 가능
      - [하나의 값을 관리]
      정수형    int     int()
      실수형    float   float()
      논리형    bool    bool()

      - [여러 값을 묶어서 관리] - 요소의 타입이 달라도 묶을 수 있음(문자열 제외)
      문자형    str     str()     '',""
      리스트    list    list()    []
      튜플      tuple   tuple()   ()
      딕셔너리  dict    dict()    {}
      집합      set     set()     {}

      - None : 아무 것도 없는 상태

  [Variable]
    - 타입을 지정하지 않고 변수를 생성
    - 타입을 지정하지 않아 어떤 타입이든 대입가능
    - 파이썬에서 변수는 주소를 저장 - 참조변수

  [Operator]  
    [대입 연산자]
      = : 대입 연산자
        - 대입 연산자 왼쪽에 여러 개의 변수가 올 수 있음
          대입할 값은 변수의 수와 같아야 함
        ex) n1, n2 = 5, 3

    [산술 연산자]
      +  : 덧셈 
      -  : 뺄셈
      *  : 곱셈
      ** : 제곱
      /  : 몫1(소수점까지)
      // : 몫2(정수까지)
      %  : 나머지

    [관계 연산자] - True, False도 클래스라 첫 글자가 대문자로 나옴
      >  : 크다, 초과
      >= : 크거나 같다, 이상
      <  : 작다, 미만
      <= : 작거나 같다, 이하
      == : 같다
      != : 다르다

    [논리 연산자]
      and : 교집합 - 이항연산자
      or  : 합집합 - 이항연산자
      not : 여집합 - 단항연산자
      - 컴퓨터가 논리값을 정수로 바꿀 땐 2진수로 바꿔 
        True = 1, False = 0으로 고정
      - 정수를 논리값으로 바뀔 땐 0을 제외한 나머지를 모두 True로 바뀜

    [조건 연산자]
      True일때 if 조건 else False일때
      - 조건이 True일 때 왼쪽 영역 실행 조건이 False일 때 else 오른쪽 영역 실행
  
  [list]
    - [요소1, 요소2, 요소3, ...]
    - 저장 순서가 보장
    - 2차원 배열형식처럼 리스트 내 리스트에 접근 가능
      ex) data = [2, 3.5, [1, 3, 5],'Hello']
          data[2][-1] -> 5

    - indexing : index로 요소에 접근 - 0부터 시작
      ex) data[0]
      - 해당 타입으로 반환

    - 인덱스 시작 기준을 바꿀 수 있음
      ex) data[-1] -> 마지막 인덱스 접근
          data[-2] -> 마지막-1 인덱스 접근

    - slicing : 연속된 여러개 요소 추출 / 범위에 해당되는 결과를 복사
      ex) data[0:2] -> 끝값은 제외

      - 원래 타입 그대로 반환

      - 시작 값을 생략하면 처음부터 추출
        ex) data[:2] -> 0~1

      - 끝 값을 생략하면 끝까지 추출
        ex) data[2:] -> 2~마지막

      - 시작 값과 끝 값을 생략하면 모두 추출
        ex) data[:] -> data와 결과는 같음
        - 대입을 해줄 때 
          a = data    -> 리스트의 주소를 대입해 a를 수정하면 data의 값도 변함
          a = data[:] -> 리스트의 요소들을 복사한 후 대입해 a를 수정해줘도 data의 값이 변하지 않음

    - step(증감폭)
      - [start : end : step]
      - 기본값 1
      - 양수는 증가, 음수는 감소(자동으로 역순)
    
    - 리스트 연산자

      + : 리스트 요소 합치기
        ex) even = [2,4,6,8]
            odd = [1,3,5,7]
            even + odd -> [2, 4, 6, 8, 1, 3, 5, 7]

      * : 리스트 요소 반복
            even * 3 -> [2, 4, 6, 8, 2, 4, 6, 8, 2, 4, 6, 8]

    - 리스트 함수
      
      [정렬](문자(영어, 한글), 숫자 전부 가능)
        문법 : 리스트.sort() : 오름차순
        문법 : 리스트.sort(reverse=True) : 내림차순

        - 문자열일 경우 시작문자부터 비교, 같으면 다음 문자 비교
          ex) 정렬 전 alphabet >>  ['cat', 'banana', 'apple', 'egg', 'dog', 'car']

          오름차순 정렬 후 alphabet >>  ['apple', 'banana', 'car', 'cat', 'dog', 'egg']
      
      [역순]
        문법 : reverse() : 리스트를 역순으로 만듦

      [특정 요소의 인덱스]
        문법 : 리스트.index(요소)

        - 왼쪽부터 탐색해서 처음으로 만난 인덱스 리턴
        - 해당 요소가 없다면 에러

      [요소 추가 : 마지막 위치]
        문법 : 리스트.append(값)

      [요소 추가 : 특정 위치]
        문법 : 리스트.insert(인덱스, 값)

      [요소 추가/확장 : 여러 요소 추가]
        문법 : 리스트.extend(리스트)
        - 리스트 연산자 + 와 같은 효과
        - 마지막에 추가

      [요소 제거]
        문법 : 리스트.remove(요소)

      [요소 제거 : 요소 리턴]
        문법 : 리스트.pop() -> 마지막 요소 리턴
        문법 : 리스트.pop(인덱스)

      [요소 제거] - 리스트 함수X
        문법 : del 리스트[인덱스]
        - 인덱싱 형식

        문법 : del 리스트[start:end]
        - 슬라이싱 형식
        - 여러 요소 제거 가능

      [특정 요소 개수]
        문법 : 리스트.count(요소)

    - 리스트 요소 수정
        - 인덱싱
          - 지정한 인덱스 요소 수정

        - 슬라이싱
          - 여러 값 수정
          - 반복가능한 값, 여러 값 형태만 대입 가능
  
  [Tuple]
    - *튜플과 리스트간에 변경은 자유롭게 가능*
    - 여러 값을 묶어서 하나의 데이터 형태로 관리
    - (요소1, 요소2, 요소3)
    - 인덱스로 요소에 접근(0부터 시작)
    - 저장 순서가 보장
    - 요소의 추가, 삭제, 수정이 불가능
    - 요소의 변경이 없는 상태를 유지할 때 사용
    - 파이썬에서 괄호가 없어도 여러 값을 대입하면 튜플로 설정
      ex) tu3 = 5, 7, 9 -> (5,7,9)

      - 괄호가 있어도 요소가 1개일 때 int와 구분이 되지 않아 요소 뒤에 ',' 추가
      ex) tu2 = (5) -> 5
          tu2 = (5,) -> (5,)

    [연산자] - 요소를 복사해 사용 가능

      + : 두 튜플의 요소를 합침

      * : 튜플을 x번 반복함

  [리스트와 튜플 저장]
    - 리스트와 튜플은 요소에 주소를 저장 -> 요소의 변경은 주소의 변경
    - 리스트와 튜플은 배열 형식으로 저장되지만 요소들은 연속된 주소를 가지지 않음

  [Str]
    - ' ', " "로 표현
    - 여러 라인을 표현할 땐 ''' ''', """ """
    - 여러 라인 주석도 문자열이지만 변수에 저장을 하지 않아 다음에 사용이 불가능한 문자열
    - 문자열로 묶은 따옴표와 다른 따옴표는 인식이 안됨
      - 같은 따옴표를 사용할 땐 따옴표 앞에 '\'를 붙이면 사용 가능

    [escape 문자]
      - '\' + 특정 문자 -> 특수 문자로 제어 시퀀스를 실행
        ex) \n : 개행문자(줄바꿈)
            \t : tab
            \', \" : ', "을 문자취급
            \\ : \를 문자취급

    - 인덱싱, 슬라이싱 사용 가능

    -[문자열 연산자]-
      
      + : 이어줌

      * : 반복

    -[문자열 함수]-

      [특정 문자열 개수]
        - 문법 : 문자열.count(문자)

      [공백 제거]
        - 문자 사이의 공백은 지우지 못 함

        [왼쪽 공백 제거]
          - 문법 : 문자열.lstrip()

        [오른쪽 공백 제거]
          - 문법 : 문자열.rstrip()

        [양쪽 공백 제거]
          - 문법 : 문자열.strip()

      [대소문자 변경]
        [대문자 변경]
          - 문법 : 문자열.upper()
        [소문자 변경]
          - 문법 : 문자열.lower()

      [특정 문자의 인덱스(대소문자 구분)]
        - 문법 : 문자열.find(찾고자 하는 문자열)
          - 없는 문자열을 찾으면 -1

        - 문법 : 문자열.index(찾고자 하는 문자열)
          - 없는 문자열을 찾으면 error

      [특정 문자 변경]
        - 문법 : 문자열.replace('old', 'new')

      [문자열 나누기]
        - 문법 : 문자열.split(나누고자 하는 문자)
          - 기준이 된 문자는 결과에 포함되지 않음
          - split 실행 결과는 list로 반환

      [특정 문자 추가] - 요소 사이마다 추가
        - 문법 : '추가할 문자'.join(문자열)
        - 문법 : '추가할 문자'.join(여러값)
    
    -[문자열 포맷]-
      
      [문자열 포맷 코드(서식문자)]
        - %s : 문자열(string)
        - %c : 문자
        - %d : 정수
        - %f : 실수
        - %% : 문자 % 
      
      [서식문자 사용법]
      ex) print('사과가 %d개 있고, 바나나는 %d개 있다.'
      %(apple,banana))
          사과가 5개 있고, 바나나는 7개 있다.

      - 서식문자가 1개일 때 소괄호를 생략 가능
      ex) print('%d'%apple)
          5

      - 서식문자가 포함된 문자열을 변수에 저장해서 사용 가능 
      
      =[정수]=
      [자릿수 지정]
        ex) print('%4d'%apple) -> apple을 4자리로 표현 / 기본은 오른쪽 정렬
            ___5 -> 비어있는 자리는 공백
        
        ex) print('%04d'%apple) -> apple을 4자리로 표현 공백은 0으로 표현 / 서식문자는 공백표현은 0으로만 가능
            0005 -> 비어있는 자리는 0

        ex) print('%-4d'%apple) -> 왼쪽 정렬
            5___ -> 왼쪽정렬은 비어있는 자리는 0으로 표현 불가 / 데이터의 변형이기 때문에
        
        - 데이터의 길이가 자릿수보다 길다면 왼쪽정렬

      [양수 표현]
        ex) print('%+d'%apple) 
            +5
        - 음수는 음수표현 그대로 표현

      =[실수]=
        ex) print('현재 실수는 %f입니다.'%fo)
            현재 실수는 2.340000입니다.
        - 실수는 기본으로 소수점 6자리까지 표현

      [소수점 자리] - 소수자릿수는 강제성 있음
        ex) print('현재 실수는 %.2f입니다.'%fo)
            현재 실수는 2.34입니다.

        ex) print('현재 실수는 %.1f입니다.'%fo)
            현재 실수는 2.3입니다.
        - 지정한 소수점아래는 반올림

      [전체 자릿수]
        ex) print('%5.2f'%fo) - 정수, ., 소수 전부 포함해서 자릿수 표현
            _2.36

        - 표현할 자릿수가 전체 자릿수보다 작다면 그냥 출력

      =[문자]=
        - 아스키 코드값으로도 표현 가능
        - 숫자(아스키 코드값)로 문자, 정수 둘 다 표현 가능하지만, 문자로는 정수표현 불가능(파이썬은 문자개념이 없기 때문에)

      =[문자열]=
        - 모든 타입은 문자열로 표현 가능하지만 모든 문자열은 모든 타입으로 표현 가능하진 않다

      =[%%]=
        - 문자열 안에 서식문자를 사용했을 때 %표현은 모두 서식문자로 취급
        - 서식문자를 사용한 문자열에서 %를 사용할 땐 %%로 표현 

    -[format]-
      - 문법 : 문자열.format()
      - 문자열{}.format(값)
        ex) print('사과가 {}개 있고, 바나나는 {}개 있다.'.format('two',banana))
            사과가 two개 있고, 바나나는 7개 있다.

        - 서식 문자를 적지 않아도 자동으로 표현

        ex) print('사과가 {0}개 있고, 바나나는 {1}개 있다.'.format('two',banana))
            사과가 two개 있고, 바나나는 7개 있다.

        - {} 안에 인덱스가 들어있어 서식문자를 안 적어도 사용 가능

        ex) print('사과가 {0}개 있고, 바나나는 {0}개 있다.'.format(apple))
            사과가 5개 있고, 바나나는 5개 있다.

        - {} 안에 같은 인덱스를 적어 중복 사용 가능

      =[f 문자 포맷팅]= : 3.6부터 지원
      
        ex) print(f'사과가 {apple}개 있고, 바나나는 {banana}개 있다.')
            사과가 5개 있고, 바나나는 7개 있다.

        - 변수로 저장해서 사용 가능
        ex) fruit = f'사과가 {apple}개 있고, 바나나는 {banana}개 있다.'
      
        [자릿수 지정]
        
          ex) print(f'{apple:7}')
              ______5

          - 공백 지정
          ex) print(f'{apple:07}')
              0000005
          
          - 왼쪽 정렬
          ex) print(f'{apple:<7}')
              5______

          - 오른쪽 정렬
          ex) print(f'{apple:>7}')
              ______5

          - 가운데 정렬
          ex) print(f'{apple:^7}')
              ___5___

          - 정렬 공백 지정(정렬기호 왼쪽에 기호를 적어 공백 지정을 하면 다른 기호도 사용 가능)
          ex) print(f'{apple:=^7}')
              ===5===

          ex) print(f'{apple:!^7}')
              !!!5!!!

  [Dictionary]
    - Json파일을 Python에서 사용하기 위해 만든 자료형

    - {key : value, key : value} 형태로 요소를 저장
    ex) hong = {'name' : '홍길동', 'age' : 35, 'address' : '서울 서대문구'}

    - 저장 순서 보장X -> 인덱스 사용X
      - 변경이 없어도 순서가 유지 안 될 수도 있음
        ex) dc = {'이름' : '홍길동', '나이' : 35, '이름' : '박보검', '주소' : '서대문구'}
            dc >>  {'이름': '박보검', '나이': 35, '주소': '서대문구'}

    - 키로 값 접근 - 키는 값을 구분하는 기준 -> 중복X, 변경X
      - 변수[key]
        ex) print(hong['name'])
        홍길동

      - 키는 변경 불가능한 타입만 올 수 있음 -> 문자 상수, 정수 상수, 실수 상수, 튜플

      - 존재하지 않는 키에 접근하면 error

      - 키가 중복되면 데이터에 변형이 생겨 사용X
        - 중복된 키는 뒤에 오는 키의 값을 따라감

      - ***key값이 정수일 수도 있기 때문에 데이터의 타입을 항상 확인해야 함***

    -[요소 추가]- 
      - 변수[키] = 값
        ex) hong['phone']='010-1111-1111'
            hong >>  {'name': '홍길동', 'age': 35, 'address': '서울 서대문구', 'phone': '010-1111-1111'}

    -[값 변경]-
      - 변수[기존 키] = value
        ex) hong['age'] = 100
            hong >>  {'name': '홍길동', 'age': 100, 'address': '서울 서대문구', 'phone': '010-1111-1111'}

    -[요소 삭제]-
      - del 변수[키]
        ex) del hong['phone']
            hong >>  {'name': '홍길동', 'age': 100, 'address': '서울 서대문구'}

    -[딕셔너리 함수]-
      
      =[값 추출]=
        - 변수.get(키)
          ex) hong.get('phone')
              연락처 >>  010-1111-1111
        
        - 존재하지 않는 키값을 넣으면 None 출력
        - 키가 없을 때 보여줄 값을 설정 가능
          ex) hong.get('address', '주소 없음')
              주소 >>  주소 없음

      =[키 추출]=
        - 변수.keys()
          ex) hong.keys()
              dict_keys(['name', 'age', 'phone'])
          
        - 리턴 : dict_keys타입 -> 기본타입X -> 리스트로 감싸짐
          - 인덱스로 접근 불가능 -> 리스트 변환 후 사용 or 반복문 사용
      
      =[값 추출]=
        - 변수.values()
          ex) hong.values()
              dict_values(['홍길동', 100, '010-1111-1111'])

        - 리턴 : dict_values타입 -> 기본타입X -> 리스트로 감싸짐
           - 인덱스로 접근 불가능 -> 리스트 변환 후 사용 or 반복문 사용

      =[키 값 추출]=
        - 변수.items()
          ex) hong.items()
              dict_items([('name', '홍길동'), ('age', 100), ('phone', '010-1111-1111')])

        - 리턴 : dict_items타입 -> 기본타입X -> 키 값 쌍은 튜플로, 튜플은 리스트로 감싸짐
           - 인덱스로 접근 불가능 -> 리스트 변환 후 사용 or 반복문 사용

      =[존재 여부]= / 연산자
        - 값 in 여러 값(리스트, 튜플, 문자열 ...)
          ex) print('name' in hong)
              True
        
        - 기본적으로 딕셔너리는 키를 기준으로 확인
        - 다른 문법에서는 다른 의미로 사용

      =[요소 추가]=
        - 변수.update({키 : 값,...})
          ex) hong.update({'주소' : '서울 강남구'})
              {'name': '홍길동', 'age': 100, 'phone': '010-1111-1111', '주소': '서울 강남구'}

          ex) hong.update({'취미' : '쉬기', '특기' : '성실함'})

          ex) hong.update({'age' : 500})
          - 존재하는 키를 update하면 값 수정

      =[모든 요소 삭제]=
        - 변수.clear()
          ex) hong.clear()
              모든 요소 삭제 후 >>  {}