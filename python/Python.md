  [Python]
    - 라이브러리와 호환성을 위해 낮은 버전을 사용
    - 라이브러리와 가장 호환이 잘 되는 버전은 7버전
    - 절차지향과 객체지향의 특성을 둘 다 가지고 있음
      - 모든 것을 객체로 만들어 사용
      - 라인을 위에서 하나씩 처리
    - 라인을 하나씩 처리 -> 인터프리터 언어(대화형 언어)
    - 문자와 문자열을 구분하지 않음 -> '', "" 둘 다 표현 가능 / 내부적으론 ''로 관리
    - 파이썬 파일(.py) - Module(실행단위) - script(실행파일) / 파이썬파일은 script라 실행파일로 작동함
    - Java의 메소드 = 함수
    - 파이썬은 2버전과 3버전의 문법이 다름
    - 파이썬은 메모리를 알아서 관리해 메모리 할당, 해제를 자동으로 처리

  [Type]
    - 정수형, 실수형은 있지만 크기가 고정되지 않음
    - 파이썬은 여러 개의 값은 항상 묶어서 관리

    - 타입 변환은 변환이 가능해야 함수 사용 가능
      - [하나의 값을 관리]
      정수형    int     int()
      실수형    float   float()
      논리형    bool    bool()

      - [여러 값을 묶어서 관리] - 요소의 타입이 달라도 묶을 수 있음(문자열 제외)
      문자형    str     str()     '',""
      리스트    list    list()    []
      튜플      tuple   tuple()   ()
      딕셔너리  dict    dict()    {}
      집합      set     set()     {}

      - None : 아무 것도 없는 상태

      ○ mutable : 변경 가능한 타입
        - 리스트, 딕셔너리

      ○ immutable : 변경 불가능한 타입
        - 정수, 실수, 문자열, 튜플

  [Variable]
    - 타입을 지정하지 않고 변수를 생성
    - 타입을 지정하지 않아 어떤 타입이든 대입가능
    - 파이썬에서 변수는 주소를 저장 - 참조변수
    - 파이썬에서 실행이 종료되기 전까지 생성한 변수 사용 가능

    ● [변수의 종류]
      ○ 전역 변수 : 함수 외에 생성된 변수
      ○ 지역 변수 : 함수 내에 생성된 변수

  [Operator]  
    [대입 연산자]
      = : 대입 연산자
        - 대입 연산자 왼쪽에 여러 개의 변수가 올 수 있음
          대입할 값은 변수의 수와 같아야 함
        ex) n1, n2 = 5, 3

    [산술 연산자]
      +  : 덧셈
      -  : 뺄셈
      *  : 곱셈
      ** : 제곱
      /  : 몫1(소수점까지)
      // : 몫2(정수까지)
      %  : 나머지

    [관계 연산자] - True, False도 클래스라 대문자로 시작
      >  : 크다, 초과
      >= : 크거나 같다, 이상
      <  : 작다, 미만
      <= : 작거나 같다, 이하
      == : 같다
      != : 다르다

    [논리 연산자]
      and : 교집합 - 이항연산자
      or  : 합집합 - 이항연산자
      not : 여집합 - 단항연산자
      - 컴퓨터가 논리값을 정수로 바꿀 땐 2진수로 바꿔 
        True = 1, False = 0으로 고정
      - 정수를 논리값으로 바뀔 땐 0을 제외한 나머지를 모두 True로 바뀜

    [조건 연산자]
      True일때 if 조건 else False일때
      - 조건이 True일 때 왼쪽 영역 실행 조건이 False일 때 else 오른쪽 영역 실행

    [연산자]
      - del : 요소 삭제
      - in  : - 여러 값 : 포함 여부 확인
              - 반복문 : 여러 값의 요소 
      - +   : concatenate - 문자열 연결
        - 문자열 + 정수 - Error
        - 정수 + 문자열 - Error

  [function]
    [내장 함수]
      - type(Object) - class 타입

      - id(Object) - 주소값

      - len(Object) - 길이

      - max(args,Iterable) - 최댓값

      - sum(Iterable) - 입력값의 합

      - range(start, end, step) - 시작 위치 ~ 끝-1만큼 숫자 생성(튜플)
        - 끝 값만 입력하면 0 ~ 끝-1까지
        - 시작, 끝, 간격을 입력하면 시작 ~ 끝-1까지 증감폭만큼 증감하는 숫자 생성
          - 증감폭이 맞지 않으면 실행X
        - 많은 양의 데이터를 만드는 데 효율적이지 않음

      - enumerate(여러 값, 시작 값) - 반복문이 실행될 때 자동으로 증가하는 값 생성
        - 리턴 : 튜플
        - 기본 시작 값 : 0
        
        ex) for score in enumerate(math):
              print(score)
            (0, 90)
            (1, 45)
            (2, 60)
            (3, 75)
            (4, 50)

    [외장 함수]
      [random]
        - shuffle
          ex) random.shuffle(여러 값)
          
  [list]
    - [요소1, 요소2, 요소3, ...]
    - 저장 순서가 보장
    - 2차원 배열형식처럼 리스트 내 리스트에 접근 가능
      ex) data = [2, 3.5, [1, 3, 5],'Hello']
          data[2][-1] -> 5

    - indexing : index로 요소에 접근 - 0부터 시작
      ex) data[0]
      - 해당 타입으로 반환

    - 인덱스 시작 기준을 바꿀 수 있음
      ex) data[-1] -> 마지막 인덱스 접근
          data[-2] -> 마지막-1 인덱스 접근

    - slicing : 연속된 여러개 요소 추출 / 범위에 해당되는 결과를 복사
      ex) data[0:2] -> 끝값은 제외

      - 원래 타입 그대로 반환

      - 시작 값을 생략하면 처음부터 추출
        ex) data[:2] -> 0~1

      - 끝 값을 생략하면 끝까지 추출
        ex) data[2:] -> 2~마지막

      - 시작 값과 끝 값을 생략하면 모두 추출
        ex) data[:] -> data와 결과는 같음
        - 대입을 해줄 때 
          a = data    -> 리스트의 주소를 대입해 a를 수정하면 data의 값도 변함
          a = data[:] -> 리스트의 요소들을 복사한 후 대입해 a를 수정해줘도 data의 값이 변하지 않음

    - step(증감폭)
      - [start : end : step]
      - 기본값 1
      - 양수는 증가, 음수는 감소(자동으로 역순)
    
    - 리스트 연산자

      + : 리스트 요소 합치기
        ex) even = [2,4,6,8]
            odd = [1,3,5,7]
            even + odd -> [2, 4, 6, 8, 1, 3, 5, 7]

      * : 리스트 요소 반복
            even * 3 -> [2, 4, 6, 8, 2, 4, 6, 8, 2, 4, 6, 8]

    - 리스트 함수
      
      [정렬](문자(영어, 한글), 숫자 전부 가능)
        문법 : 리스트.sort() : 오름차순
        문법 : 리스트.sort(reverse=True) : 내림차순

        - 문자열일 경우 시작문자부터 비교, 같으면 다음 문자 비교
          ex) 정렬 전 alphabet >>  ['cat', 'banana', 'apple', 'egg', 'dog', 'car']

          오름차순 정렬 후 alphabet >>  ['apple', 'banana', 'car', 'cat', 'dog', 'egg']
      
      [역순]
        문법 : reverse() : 리스트를 역순으로 만듦

      [특정 요소의 인덱스]
        문법 : 리스트.index(요소)

        - 왼쪽부터 탐색해서 처음으로 만난 인덱스 리턴
        - 해당 요소가 없다면 에러

      [요소 추가 : 마지막 위치]
        문법 : 리스트.append(값)

      [요소 추가 : 특정 위치]
        문법 : 리스트.insert(인덱스, 값)

      [요소 추가/확장 : 여러 요소 추가]
        문법 : 리스트.extend(리스트)
        - 리스트 연산자 + 와 같은 효과
        - 마지막에 추가

      [요소 제거]
        문법 : 리스트.remove(요소)

      [요소 제거 : 요소 리턴]
        문법 : 리스트.pop() -> 마지막 요소 리턴
        문법 : 리스트.pop(인덱스)

      [요소 제거] - 리스트 함수X
        문법 : del 리스트[인덱스]
        - 인덱싱 형식

        문법 : del 리스트[start:end]
        - 슬라이싱 형식
        - 여러 요소 제거 가능

      [특정 요소 개수]
        문법 : 리스트.count(요소)

    - 리스트 요소 수정
      - 인덱싱
        - 지정한 인덱스 요소 수정

      - 슬라이싱
        - 여러 값 수정
        - 반복가능한 값, 여러 값 형태만 대입 가능

  [Tuple]
    - *튜플과 리스트간에 변경은 자유롭게 가능*
    - 여러 값을 묶어서 하나의 데이터 형태로 관리
    - (요소1, 요소2, 요소3)
    - 인덱스로 요소에 접근(0부터 시작)
    - 저장 순서가 보장
    - 요소의 추가, 삭제, 수정이 불가능
    - 요소의 변경이 없는 상태를 유지할 때 사용
    - 파이썬에서 여러 값을 기본적으로 튜플로 관리
      ex) tu3 = 5, 7, 9 -> (5,7,9)
          n1, n2 = 5, 3 -> n1 = 5, n2 = 3
    - 튜플에서 변경은 요소의 주소 변경을 의미

    - 괄호가 있어도 요소가 1개일 때 int와 구분이 되지 않아 요소 뒤에 ',' 추가
      ex) tu2 = (5) -> 5
          tu2 = (5,) -> (5,)

    [연산자] - 요소를 복사해 사용 가능

      + : 두 튜플의 요소를 합침

      * : 튜플을 x번 반복함

    [함수]

      .index(요소) : 요소 인덱스 확인

      .count(요소) : 요소 개수 확인

  [리스트와 튜플 저장]
    - 리스트와 튜플은 요소에 주소를 저장 -> 요소의 변경은 주소의 변경
    - 리스트와 튜플은 배열 형식으로 저장되지만 요소들은 연속된 주소를 가지지 않음
  
  [Str]
    - ' ', " "로 표현
    - 여러 라인을 표현할 땐 ''' ''', """ """
    - 여러 라인 주석도 문자열이지만 변수에 저장을 하지 않아 다음에 사용이 불가능한 문자열
    - 문자열로 묶은 따옴표와 다른 따옴표는 인식이 안됨
      - 같은 따옴표를 사용할 땐 따옴표 앞에 '\'를 붙이면 사용 가능

    [escape 문자]
      - '\' + 특정 문자 -> 특수 문자로 제어 시퀀스를 실행
        ex) \n : 개행문자(줄바꿈)
            \t : tab
            \', \" : ', "을 문자취급
            \\ : \를 문자취급

    - 인덱싱, 슬라이싱 사용 가능

    -[문자열 연산자]-
      
      + : 이어줌

      * : 반복

    -[문자열 함수]-

      [특정 문자열 개수]
        - 문법 : 문자열.count(문자)

      [공백 제거]
        - 문자 사이의 공백은 지우지 못 함

        [왼쪽 공백 제거]
          - 문법 : 문자열.lstrip()

        [오른쪽 공백 제거]
          - 문법 : 문자열.rstrip()

        [양쪽 공백 제거]
          - 문법 : 문자열.strip()

      [대소문자 변경]
        [대문자 변경]
          - 문법 : 문자열.upper()
        [소문자 변경]
          - 문법 : 문자열.lower()

      [특정 문자의 인덱스(대소문자 구분)]
        - 문법 : 문자열.find(찾고자 하는 문자열)
          - 없는 문자열을 찾으면 -1

        - 문법 : 문자열.index(찾고자 하는 문자열)
          - 없는 문자열을 찾으면 error

      [특정 문자 변경]
        - 문법 : 문자열.replace('old', 'new')

      [문자열 나누기]
        - 문법 : 문자열.split(나누고자 하는 문자)
          - 기준이 된 문자는 결과에 포함되지 않음
          - split 실행 결과는 list로 반환

      [특정 문자 추가] - 요소 사이마다 추가
        - 문법 : '추가할 문자'.join(문자열)
        - 문법 : '추가할 문자'.join(여러값)
    
    -[문자열 포맷]-
      
      [문자열 포맷 코드(서식문자)]
        - %s : 문자열(string)
        - %c : 문자
        - %d : 정수
        - %f : 실수
        - %% : 문자 % 
      
      [서식문자 사용법]
      ex) print('사과가 %d개 있고, 바나나는 %d개 있다.'
      %(apple,banana))
          사과가 5개 있고, 바나나는 7개 있다.

      - 서식문자가 1개일 때 소괄호를 생략 가능
      ex) print('%d'%apple)
          5

      - 서식문자가 포함된 문자열을 변수에 저장해서 사용 가능 
      
      =[정수]=
      [자릿수 지정]
        ex) print('%4d'%apple) -> apple을 4자리로 표현 / 기본은 오른쪽 정렬
            ___5 -> 비어있는 자리는 공백
        
        ex) print('%04d'%apple) -> apple을 4자리로 표현 공백은 0으로 표현 / 서식문자는 공백표현은 0으로만 가능
            0005 -> 비어있는 자리는 0

        ex) print('%-4d'%apple) -> 왼쪽 정렬
            5___ -> 왼쪽정렬은 비어있는 자리는 0으로 표현 불가 / 데이터의 변형이기 때문에
        
        - 데이터의 길이가 자릿수보다 길다면 왼쪽정렬

      [양수 표현]
        ex) print('%+d'%apple) 
            +5
        - 음수는 음수표현 그대로 표현

      =[실수]=
        ex) print('현재 실수는 %f입니다.'%fo)
            현재 실수는 2.340000입니다.
        - 실수는 기본으로 소수점 6자리까지 표현

      [소수점 자리] - 소수자릿수는 강제성 있음
        ex) print('현재 실수는 %.2f입니다.'%fo)
            현재 실수는 2.34입니다.

        ex) print('현재 실수는 %.1f입니다.'%fo)
            현재 실수는 2.3입니다.
        - 지정한 소수점아래는 반올림

      [전체 자릿수]
        ex) print('%5.2f'%fo) - 정수, ., 소수 전부 포함해서 자릿수 표현
            _2.36

        - 표현할 자릿수가 전체 자릿수보다 작다면 그냥 출력

      =[문자]=
        - 아스키 코드값으로도 표현 가능
        - 숫자(아스키 코드값)로 문자, 정수 둘 다 표현 가능하지만, 문자로는 정수표현 불가능(파이썬은 문자개념이 없기 때문에)

      =[문자열]=
        - 모든 타입은 문자열로 표현 가능하지만 모든 문자열은 모든 타입으로 표현 가능하진 않다

      =[%%]=
        - 문자열 안에 서식문자를 사용했을 때 %표현은 모두 서식문자로 취급
        - 서식문자를 사용한 문자열에서 %를 사용할 땐 %%로 표현 

    -[format]-
      - 문법 : 문자열.format()
      - 문자열{}.format(값)
        ex) print('사과가 {}개 있고, 바나나는 {}개 있다.'.format('two',banana))
            사과가 two개 있고, 바나나는 7개 있다.

        - 서식 문자를 적지 않아도 자동으로 표현

        ex) print('사과가 {0}개 있고, 바나나는 {1}개 있다.'.format('two',banana))
            사과가 two개 있고, 바나나는 7개 있다.

        - {} 안에 인덱스가 들어있어 서식문자를 안 적어도 사용 가능

        ex) print('사과가 {0}개 있고, 바나나는 {0}개 있다.'.format(apple))
            사과가 5개 있고, 바나나는 5개 있다.

        - {} 안에 같은 인덱스를 적어 중복 사용 가능

      =[f 문자 포맷팅]= : 3.6부터 지원
      
        ex) print(f'사과가 {apple}개 있고, 바나나는 {banana}개 있다.')
            사과가 5개 있고, 바나나는 7개 있다.

        - 변수로 저장해서 사용 가능
        ex) fruit = f'사과가 {apple}개 있고, 바나나는 {banana}개 있다.'
      
        [자릿수 지정]
        
          ex) print(f'{apple:7}')
              ______5

          - 공백 지정
          ex) print(f'{apple:07}')
              0000005
          
          - 왼쪽 정렬
          ex) print(f'{apple:<7}')
              5______

          - 오른쪽 정렬
          ex) print(f'{apple:>7}')
              ______5

          - 가운데 정렬
          ex) print(f'{apple:^7}')
              ___5___

          - 정렬 공백 지정(정렬기호 왼쪽에 기호를 적어 공백 지정을 하면 다른 기호도 사용 가능)
          ex) print(f'{apple:=^7}')
              ===5===

          ex) print(f'{apple:!^7}')
              !!!5!!!

  [Dictionary]
    - Json타입을 Python에서 사용하기 위해 만든 자료형

    - {key : value, key : value} 형태로 요소를 저장
    ex) hong = {'name' : '홍길동', 'age' : 35, 'address' : '서울 서대문구'}

    - 저장 순서 보장X -> 인덱스 사용X
      - 변경이 없어도 순서가 유지 안 될 수도 있음
        ex) dc = {'이름' : '홍길동', '나이' : 35, '이름' : '박보검', '주소' : '서대문구'}
            dc >>  {'이름': '박보검', '나이': 35, '주소': '서대문구'}

    - 키로 값 접근 - 키는 값을 구분하는 기준 -> 중복X, 변경X
      - 변수[key]
        ex) print(hong['name'])
        홍길동

      - 키는 변경 불가능한 타입만 올 수 있음 -> 문자 상수, 정수 상수, 실수 상수, 튜플

      - 존재하지 않는 키에 접근하면 error

      - 키가 중복되면 데이터에 변형이 생겨 사용X
        - 중복된 키는 뒤에 오는 키의 값을 따라감

      - ***key값이 정수일 수도 있기 때문에 데이터의 타입을 항상 확인해야 함***

    -[요소 추가]- 
      - 딕셔너리[키] = 값
        ex) hong['phone']='010-1111-1111'
            hong >>  {'name': '홍길동', 'age': 35, 'address': '서울 서대문구', 'phone': '010-1111-1111'}

    -[값 변경]-
      - 딕셔너리[기존 키] = value
        ex) hong['age'] = 100
            hong >>  {'name': '홍길동', 'age': 100, 'address': '서울 서대문구', 'phone': '010-1111-1111'}

    -[요소 삭제]-
      - del 딕셔너리[키]
        ex) del hong['phone']
            hong >>  {'name': '홍길동', 'age': 100, 'address': '서울 서대문구'}

    -[딕셔너리 함수]-
      
      =[값 추출]=
        - 딕셔너리.get(키)
          ex) hong.get('phone')
              연락처 >>  010-1111-1111
        
        - 존재하지 않는 키값을 넣으면 None 출력
        - 키가 없을 때 보여줄 값을 설정 가능
          ex) hong.get('address', '주소 없음')
              주소 >>  주소 없음

      =[키 추출]=
        - 딕셔너리.keys()
          ex) hong.keys()
              dict_keys(['name', 'age', 'phone'])
          
        - 리턴 : dict_keys타입 -> 기본타입X -> 리스트로 감싸짐
          - 인덱스로 접근 불가능 -> 리스트 변환 후 사용 or 반복문 사용
      
      =[값 추출]=
        - 딕셔너리.values()
          ex) hong.values()
              dict_values(['홍길동', 100, '010-1111-1111'])

        - 리턴 : dict_values타입 -> 기본타입X -> 리스트로 감싸짐
           - 인덱스로 접근 불가능 -> 리스트 변환 후 사용 or 반복문 사용

      =[키 값 추출]=
        - 딕셔너리.items()
          ex) hong.items()
              dict_items([('name', '홍길동'), ('age', 100), ('phone', '010-1111-1111')])

        - 리턴 : dict_items타입 -> 기본타입X -> 키 값 쌍은 튜플로, 튜플은 리스트로 감싸짐
           - 인덱스로 접근 불가능 -> 리스트 변환 후 사용 or 반복문 사용

      =[존재 여부]= / 연산자
        - 값 in 여러 값(리스트, 튜플, 문자열 ...)
          ex) print('name' in hong)
              True
        
        - 기본적으로 딕셔너리는 키를 기준으로 확인
        - 다른 문법에서는 다른 의미로 사용

      =[요소 추가]=
        - 딕셔너리.update({키 : 값,...})
          ex) hong.update({'주소' : '서울 강남구'})
              {'name': '홍길동', 'age': 100, 'phone': '010-1111-1111', '주소': '서울 강남구'}

          ex) hong.update({'취미' : '쉬기', '특기' : '성실함'})

          ex) hong.update({'age' : 500})
          - 존재하는 키를 update하면 값 수정

      =[모든 요소 삭제]=
        - 딕셔너리.clear()
          ex) hong.clear()
              모든 요소 삭제 후 >>  {}

  [Set]
    - 수학의 집합을 표현하기 위해 사용

    - {요소1, 요소2, 요소3} 형태로 저장
      ex) s = {4, 1, 5, 7, 1, 5}

    - 저장 순서 보장 X -> 인덱스 사용 X
    - 중복값 저장 X
      ex) s >>  {1, 4, 5, 7}

    -[집합의 함수]-

      =[요소 추가]=

        [요소 1개 추가]
        - 집합.add(값)
          ex) s.add(6)

        [요소 여러 개 추가]
        - 집합.update(여러 값) - 딕셔너리 제외

      =[특정 요소 제거]=

        - 집합.remove(요소)
          ex) s.remove(8)

    -[집합]-
      ex)
      s1 = {2, 4, 6, 8}
      s2 = {1, 2, 3, 4, 5}

      =[교집합]=
        [연산자]
          - 집합 & 집합
            ex) s1 & s2
                {2, 4}
        [함수]
          - 집합.intersection(집합)
            ex) s1.intersection(s2)
                {2, 4}

      =[합집합]=
        [연산자]
          - 집합 | 집합
            ex) s1 | s2
                {1, 2, 3, 4, 5, 6, 8}
        [함수]
          - 집합.union(집합)
            ex) s1.union(s2)
                {1, 2, 3, 4, 5, 6, 8}

      =[차집합]=
        [연산자]
          - 집합 - 집합
            ex) s1 - s2
                {8, 6}
        [함수]
          - 집합.difference(집합)
            ex) s1.difference(s2)
                {8, 6}

      =[여집합]=
        [연산자]
          - 집합 ^ 집합
            ex) s1 ^ s2
                {1, 3, 5, 6, 8}
        [함수]
          - 집합.symmetric_difference(집합)
            ex) s1.symmetric_difference(s2)
                {1, 3, 5, 6, 8}

  [Bool]
    - 값   : True, False
    - type : bool
    - 함수 : bool(값) -> bool 리턴

       정수(10진수)            논리
           0                   False
    0을 제외한 모든 수         True

          문자                     
           ''                  False
    모든 문자(공백 포함)       True

         리스트
           []                  False
          
  [Copy]
    - 깊은 복사 : 주소 복사 -> 원본과 사본 모두 영향
      - 컴퓨터 기준에서 주소만 복사해 작업이 간결
    - 얕은 복사 : 데이터 복사 -> 원본과 사본 영향X
      - 해당 데이터의 값을 복사 후 생성해 작업이 복잡

      =[함수]=
        - 변수.copy()

      =[슬라이싱]=
        - 변수[:]
  
  [제어문] 

    -[조건문]-
      - 특정 상황에서 코드를 사용하기 위해 사용

      =[조건 1개]=
        - if 조건식: 
              명령어 -> 들여쓰기(인던트)로 영역
                        (레벨) 설정, 관용적으로 4칸

      =[조건 2개]=
        - if 조건식:
              명령어
          else:
              명령어

      =[조건 3개]=
        - if 조건식:
              명령어
          elif 조건식:
              명령어
          else:
              명령어
    
    -[반복문]-
      - 특정 코드를 연속해서 실행하기 위해 사용

      =[while]=
        - 초기값
          while 조건식:
              실행부    -> 들여쓰기로 영역 구분
              증감식

      =[for]=
        - for 변수 in 여러값:
              실행부
        - 여러 값의 요소만큼 반복문 실행 - 변수에는 여러 값의 요소 저장

        - for에서 받는 요소가 여러 값 형태라면 변수로 여러 개를 받을 수 있음
          ex) data = [(2, 5), (1, 4), (3, 6)]

              for first, last in data:
                print(f'first : {first}, last : {last}')
              -> first, last = (2, 5)
              -> (first, last) = (2, 5)

              first : 2, last : 5
              first : 1, last : 4
              first : 3, last : 6

        [리스트 내포] -> 리스트안에 for문
          - 명령어가 1개만 있을 경우 간결하게 표현
            - 명령어가 2개 이상일 땐 사용 불가
          
          - 간단한 일반 for문을 1줄로 표현
          - 반복문이 실행되면서 리스트, 집합에 추가

          [명령어 for 변수 in 여러값]
            ex) [print(r, end=' ') for r in range(1,10)]
                1 2 3 4 5 6 7 8 9 
          
          [변수 for 변수 in 여러값] 
            ex) even = [r for r in range(2, 11, 2)]
                even >>  [2, 4, 6, 8, 10]

          [명령어 for 변수 in 여러값 if 조건식]
            ex) [print(r, end=' ') for r in range(1, 11) if r % 3 == 0]
                3 6 9

          [조건식을 포함한 리스트 요소 추가]
            ex) even_two = [r for r in range(1, 10) if r % 2 == 0]
                [2, 4, 6, 8] 

    [pass]
      - 문법의 형태를 맞춰주며 실행은 하지 않을 때 사용
      ex) if num > 0:
              pass
    
    [break]
      - 반복문 내에서 사용
      - if문과 같이 사용
      - break가 실행되면 반복문 탈출

    [continue]
      - 조건이 만족할 때 특정한 코드를 실행에서 제외
      - 반복문 내에서 사용
      - if문과 같이 사용
      - continue가 실행되면 반복문의 조건식으로 이동
    
  [출력 함수 : print]
    - help(내장함수) -> 내장함수의 정보
    - print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)
      - value : 인수
      - sep   : 매개변수 / 값 사이에 들어가는 문자
      - end   : 매개변수 / 마지막 값 뒤에 추가되는 문자
      - file  : 매개변수 
      - flush : 매개변수  

      - 매개변수를 수정할 땐 값 뒤에 추가
      ex) print('one', 'two', sep='-')
          one-two
      - 매개변수 사이엔 순서 X 

    -[file]- / 쓰기함수를 사용하는 것이 좋음
      절대경로 : 'D:\\webservice\\python\\p230413\\test.txt'
      상대경로 : 'test.txt'
      권한 : w(쓰기), r(읽기)

  [입력 함수 : input]
    - input(출력할 내용)
    - 터미널에서 입력받은 데이터는 외부에서 오는 데이터라 파이썬이 데이터를 받을 때 문자열로 데이터를 받음

    -[eval()]-
      - eval(dict)
      - 입력받은 딕셔너리를 정수, 실수로 구분

      =[여러 값 받기]=
        - ','로 여러 값 받기 가능
          ex) 숫자 2개 입력...2, 4
              one >>  (2, 4) - 여러 값은 튜플로 저장

  [Function]
    - 반복되지만 비연속적인 코드

    - 자주쓰는 코드에 이름을 붙인 것

    - 함수는 호출돼야만 사용 가능

    - 함수의 실행이 종료되면 함수를 호출한 곳으로 돌아감

    - 매개변수와 인수의 개수가 일치해야 실행 가능

    - 똑같은 함수명으로 함수를 정의해도 Error X 
      나중에 정의한 함수로 정의

    - 값을 여러 개 리턴하면 튜플로 묶어서 리턴
      - 인수를 여러 개 넘기면 Error -> 인수를 자동으로 묶으면 인수의 개수를 파악하지 못해 묶지 않음
      ex) return 100, 200 -> return (100, 200)

          def add(num):
          add(3, 5) -> Error

    ● [함수 정의] 
      ○ def 함수명(매개변수, 매개변수):
            명령어
            명령어
            return 값 
    
    ● [함수 호출] - ※절차지향적 특성때문에 먼저 정의된 함수만 사용 가능※
      ○ 함수명(인수1, 인수2)

    ● [함수 정의 형태]
      - 매개변수 o, return x
      - 매개변수 o, return o
      - 매개변수 x, return x
      - 매개변수 x, return o

    ● [함수 내 변수] - stack에 생성
      - 지역 변수 : 함수 내에서 생성한 변수
      - 기본적으로 함수 내에서 전역 변수 사용 불가
      - 지역 변수는 함수 실행이 종료되면 메모리에서 삭제 
      - 함수 내 해당 변수가 없다면 전역 변수에 접근

      ○ [전역 변수 선언]
        ◎ global 변수명
    
    ● [가변 매개 변수]
      ○ *변수명(튜플)
        ex) def add(n1, n2, *args)

      ○ **변수명(딕셔너리)
        ex) def add(**args)
            add(홍길동=90) - 홍길동 : 변수
                             90 : 값
        -> 인수로 변수와 값을 넣어주면 자동으로 key : value 형태로 저장, 변수는 자동으로 문자열로 변경

      - 추가적인 매개 변수를 받을 때 사용
      - 인수가 없어도 되고, 있다면 1개 이상

    ● [기본값 설정]
      ○ 매개변수 = 값
        ex) def default_func(arg=0):
                print('arg >>',arg)

      - 인수가 없을 때 사용하는 값

      - 인수가 입력되면 사용X

      - 기본값이 설정된 매개변수와 기본값이 설정되지 않은 매개변수가 같이 오면 기본값을 설정한 매개변수는 오른쪽 끝부터 채워 넣는다
        - 기본값을 설정한 매개변수가 중간이나 처음에 온다면 기본값을 설정하지 않은 매개변수에만 값을 넣어줄 수 없기 때문에 Error
        ex) def default1(a = 1, b = 2, c):
                print(f'a : {a}, b : {b}, c : {c}')
      
      - 매개변수를 지정해서 값을 입력가능
        ex) default(a=1,c=3)
            a : 1, b : 2, c : 3

    ● [namespace]
      - 공간에 붙인 이름
      - 변수를 사용가능한 영역

      ○ [전역]
        - globals()

      ○ [지역]
        - locals()

  [File]
    ● [파일 쓰기]
      1. open 함수 : 모드 - w, a
        ○ open('경로\파일명.확장자 or 파일명.확장자, '모드')
          ex) file = open('new.txt', 'w')
              - IDE마다 파일이 생성되는 위치가 다름
                VSC는 최상위 경로에 파일 생성

      2. write 함수 
        ○ open한 파일.write()
            ex) file.write('new.txt', 'w')

      3. close 함수
        ○ open('경로\파일명.확장자 or 파일명.확장자, '모드')
            ex) open('new.txt', 'w')
